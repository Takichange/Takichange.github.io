(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{526:function(a,t,r){"use strict";r.r(t);var e=r(15),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"理解浏览器缓存机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解浏览器缓存机制"}},[a._v("#")]),a._v(" 理解浏览器缓存机制")]),a._v(" "),r("h2",{attrs:{id:"介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),r("p",[a._v("浏览器缓存可以提高网页打开速度、减少 Http 请求，在提高用户体验、重复利用资源、减少网络带宽上发挥着重要的作用。特别是现在用户对网站响应速度要求特别高的情况下，高效地利用浏览器缓存机制可以使网站性能优化事半功倍。"),r("br"),a._v("\n下面对浏览器缓存机制做一些分析。")]),a._v(" "),r("h2",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),r("p",[a._v("HTTP 缓存可以分为强缓存和协商缓存:")]),a._v(" "),r("p",[a._v("强缓存：强缓存命中不会发送请求到服务器端，直接从本地缓存中获取资源，状态码 200 (from cache)"),r("br"),a._v("\n 协商缓存：协商缓存会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，则返回状态码 304 (not modified)，通知浏览器从缓存中获取资源。"),r("br"),a._v("\n示意图"),r("br"),a._v(" "),r("img",{attrs:{src:"/assets/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%981.png",alt:"图片"}})]),a._v(" "),r("h2",{attrs:{id:"分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[a._v("#")]),a._v(" 分析")]),a._v(" "),r("p",[a._v("根据响应头部的字段确定浏览器缓存策略"),r("br"),a._v("\n响应头中与缓存策略相关的字段包括 Cache-Control, Pragma, Expires, 下面分析这三个字段。")]),a._v(" "),r("h3",{attrs:{id:"cache-control"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),r("p",[a._v("Cache-Control 是 Http/1.1 新增的字段，是控制浏览器缓存的主要字段。它的主要内容如下：")]),a._v(" "),r("p",[a._v("no-cache：资源可以被缓存，但立刻过期，下次访问必须验证资源有效性"),r("br"),a._v("\n max-age：缓存资源，在指定时间后过期 (单位为秒)"),r("br"),a._v("\n no-store：资源不会被缓存"),r("br"),a._v("\n public：资源可以被浏览器和代理服务器缓存"),r("br"),a._v("\n private： 资源只能被浏览器缓存")]),a._v(" "),r("h3",{attrs:{id:"pragma"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pragma"}},[a._v("#")]),a._v(" Pragma")]),a._v(" "),r("p",[a._v("Pragma 是 Http/1.0 的头部字段，只有一个值 no-cache， 功能和 Cache-Control:no-cache 一样。")]),a._v(" "),r("h3",{attrs:{id:"expires"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),r("p",[a._v("Expires 是缓存到期时间，以服务器时间为参考，优先级比 Cache-Control: max-age 低。")]),a._v(" "),r("p",[a._v("在一些场景中必须避免浏览器缓存，推荐的做法是设置请求头：Cache-Control: no-cache, no-store, must-revalidate")]),a._v(" "),r("h2",{attrs:{id:"强缓存命中条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强缓存命中条件"}},[a._v("#")]),a._v(" 强缓存命中条件")]),a._v(" "),r("p",[a._v("我们会发现，最优的做法是让一些公开资源命中强缓存，这是响应最快的。那么命中强缓存的条件又是什么呢？")]),a._v(" "),r("p",[a._v("请求头部不包括 Pragma 字段"),r("br"),a._v("\n响应头部 Cache-Control 中不包括 no-cache、no-store"),r("br"),a._v("\n 响应头部 max-age 或者 Expires 大于请求日期"),r("br"),a._v("\n如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 Expires 信息，是不是就不会命中强缓存了呢？不是的，浏览器会做出优化，默认采用一个启发式算法，取响应头的 (Date - Last-Modified) * 0.1 作为缓存有效时间，只要是在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存。")]),a._v(" "),r("h2",{attrs:{id:"服务器端校验资源是否修改机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务器端校验资源是否修改机制"}},[a._v("#")]),a._v(" 服务器端校验资源是否修改机制")]),a._v(" "),r("h3",{attrs:{id:"last-modified-if-modified-since"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[a._v("#")]),a._v(" Last-Modified/If-Modified-Since")]),a._v(" "),r("p",[a._v("服务器响应资源的时候返回一个头部字段 Last-Modified，代表该资源最后修改时间，当浏览器再次向服务器请求该资源时，会传送 If-Modified-Since 信息，值就是上次服务器响应的最后修改时间， 服务器将这个请求时间与本地资源实际最后修改时间做对比，如果文件没有被修改，则返回状态码 304，通知浏览器从缓存中读取资源文件。")]),a._v(" "),r("h3",{attrs:{id:"etag-if-none-match"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[a._v("#")]),a._v(" ETag/If-None-Match")]),a._v(" "),r("p",[a._v("ETag 是一个响应首部字段，它是根据资源内容生成的一段 hash 字符串，标识资源的状态，由服务端产生。当浏览器再次向服务器请求该资源时，会传送 If-None-Match 字段，服务器收到请求后，拿 If-None-Match 字段的值与资源的实际 ETage 值进行比较，若相同，则命中协商缓存，返回状态码 304。ETag 优先级比 Last-Modified 高，同时存在时会以 ETag 为准。")]),a._v(" "),r("p",[a._v("那已经有了 Last-Modified 机制，为什么要引入 ETage 机制呢？")]),a._v(" "),r("p",[a._v("某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新"),r("br"),a._v("\n如果资源修改非常频繁，在秒以下的时间内进行修改，而 Last-Modified 只能精确到秒"),r("br"),a._v("\n一些资源的最后修改时间改变了，但是内容没改变，使用 ETag 就能判别出资源内容是否被修改")]),a._v(" "),r("h2",{attrs:{id:"浏览器缓存的使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的使用"}},[a._v("#")]),a._v(" 浏览器缓存的使用")]),a._v(" "),r("p",[a._v("使用缓存的过程其实就是根据场景设置 Cache-Control 的值的过程："),r("br"),a._v(" "),r("img",{attrs:{src:"/assets/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%982.png",alt:"图片"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);